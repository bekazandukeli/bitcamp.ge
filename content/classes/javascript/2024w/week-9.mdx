---
title: თავი 9 - Bugs And Errors - JavaScript 2024W
description: სასწავლო რესურსები
---

### ლექცია 9

<iframe width="560" height="315" src="https://www.youtube.com/embed/Kknndt74cl0?si=gbdZKncgN2alRnO1" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowFullScreen></iframe>

### პრაქტიკული სემინარები

<Card>
  <PinCodeProtectedContent>
    <Locked>
      ეს კონტენტი განკუთვნილია აქტიური სტუდენტებისთვის. პინ კოდი მოითხოვეთ
      მენტორთან!
    </Locked>
    <Unlocked>
      - ოთხშაბათი: https://youtu.be/G1xjnkySGbQ
      - პარასკევი: https://youtu.be/9W-CUPKpg4I
          - source code: [Github](https://github.com/kachkacha2003/recursionSeminar)
    </Unlocked>
  </PinCodeProtectedContent>
</Card>

### რესურსები

- წიგნი: [Eloquent JavaScript](https://eloquentjavascript.net/)
- ედიტორი: [stackblitz.com](https://stackblitz.com)
- პრეზენტაცია: [Google Slide](https://docs.google.com/presentation/d/1tQ4cDiXnK7yCu86bpzvsE4yjoQGR--A-_L-JLSxVV8s/edit?usp=sharing)

### წასაკითხი

- წაიკითხეთ თავი VIII - [Bugs and Errors](https://eloquentjavascript.net/08_error.html)

### დავალებები

#### პროექტი 42 - Anagram Checker - ანაგრამის შემმოწმებელი
შექმენით პროგრამა, რომელიც ადარებს ორ სტრიქონს და ადგენს არის თუ არა ისინი ანაგრამა (სიტყვა, რომელიც წარმოიქმნება სხვა სიტყვის ასოების გადაადგილებით). პროგრამამ უნდა მოითხოვოს ორივე input-ის წინადადება და პასუხი ისე დაბეჭდოს, როგორც მაგალითშია ნაჩვენები.

Example Output
```shell
> Enter two strings and I'll tell you if they
> are anagrams:
> Enter the first string: note
> Enter the second string: tone
> "note" and "tone" are anagrams.
```

* გამოიყენეთ ფუნქცია, სახელად isAnagram, რომელიც არგუმენტად იღებს ორ სტრიქონს და აბრუნებს boolean-ს. გამოიძახეთ ეს ფუნქცია თქვენი მთავარი ფუნქციიდან.
* შეამოწმეთ, ორივე სიტყვა ერთნაირი სიგრძისაა თუ არა.

#### პროექტი 43 - Password Strength Indicator - პაროლის სიძლიერის შემფასებელი
ექმენით პროგრამა, რომელიც განსაზღვრავს მოცემული პაროლის სიძლიერეს ამ წესების საფუძველზე:

• ძალიან სუსტი პაროლი შეიცავს მხოლოდ ციფრებს და რვა სიმბოლოზე ნაკლებია.
• სუსტი პაროლი შეიცავს მხოლოდ ასოებს და რვა სიმბოლოზე ნაკლებია.
• ძლიერი პაროლი შეიცავს ასოებს და მინიმუმ ერთ რიცხვს, ასევე, მინიმუმ რვა სიმბოლოს.
• ძალიან ძლიერი პაროლი შეიცავს ასოებს, ციფრებს და სპეციალურ სიმბოლოებს და არის მინიმუმ რვა სიმბოლოს სიგრძის.

Example Output
```shell
> The password '12345' is a very weak password.
> The password 'abcdef' is a weak password.
> The password 'abc123xyz' is a strong password.
> The password '1337h@xor!' is a very strong password.
```

* შექმენით passwordValidator ფუნქცია, რომელიც მიიღებს პაროლს არგუმენტად და დააბრუნებს მნიშვნელობას, რომელიც შეფასდება პაროლის სიძლიერის დასადგენად. ფუნქციამ არ უნდა დააბრუნოს სტრიქონის (string) ტიპის მნიშვნელობა.

#### პროექტი 44 - Months to Pay Off a Credit Card - საკრედიტო ბარათის დაფარვისთვის საჭირო თვეები
საკრედიტო ბარათის ბალანსის დაფარვას შეიძლება გაცილებით მეტი დრო დასჭირდეს, ვიდრე მის მფლობელს წარმოუდგენია. გასარკვევად ფორმულა კი არც ისე "მიმზიდველია"... მაგრამ ფორმულის სირთულე შეგიძლიათ, ფუნქციით დამალოთ. 

შექმენით პროგრამა, რომელიც დაგეხმარებათ განსაზღვროთ, რამდენი თვე დასჭირდება საკრედიტო ბარათის ბალანსის დაფარვას. პროგრამამ უნდა სთხოვოს მომხმარებელს შემდეგი ინფორმაციის შეყვანა: საკრედიტო ბარათის ბალანსი, ბარათის APR (წლიური საპროცენტო განაკვეთი), და თვიური გადასახადი. შემდეგ პროგრამამ უნდა დააბრუნოს თვეების რაოდენობა. ფორმულა შემდეგია:

![Image](/images/week3-formula.png)

• n არის თვეების რაოდენობა.
• i არის დღიური მაჩვენებელი (APR / 365).
• b - ბალანსი.
• p - ყოველთვიური გადასახდელი თანხა.

Example Output
```shell
> What is your balance? 5000
> What is the APR on the card (as a percent)? 12
> What is the monthly payment you can make? 100

> It will take you 70 months to pay off this card.
```

* გამოიყენეთ ფუნქცია, სახელწოდებით countMonthsUntilPaidOff, რომელიც არგუმენტად იღებს ბალანსს, APR-ს და ყოველთვიურ გადასახადს და აბრუნებს თვეების რაოდენობას. ამ მნიშვნელობებს ფუნქციის გარედან არ მიწვდეთ.

#### პროექტი 45 - Validating Inputs - Input-ების ვალიდაცია
ხშირად პროგრამის ლოგიკის დაშლა პატარა ფუნქციებად გვიწევს, რომლებიც თითოეულ დავალებას ასრულებენ. შემდეგ ეს ფუნქციები თანმიმდევრობით, მთლიანი პროგრამის ასამუშავებლად გამოძახება.

დაწერეთ პროგრამა, რომელიც მოგთხოვთ სახელს, გვარს, თანამშრომლის ID-ს და ZIP კოდს. დარწმუნდით, რომ input-ები ვალიდურია შემდეგი წესების მიხედვით:

• სახელი უნდა იყოს შევსებული.
• გვარი უნდა იყოს შევსებული.
• სახელი და გვარი უნდა იყოს მინიმუმ ორი სიმბოლოს სიგრძის.
• თანამშრომლის ID არის AA-1234 ფორმატში - ორი ასო, დეფისი და ოთხი რიცხვი.
• ZIP კოდი უნდა იყოს რიცხვი.

არასწორ მონაცემებზე აჩვენეთ შესაბამისი შეცდომის შეტყობინებები.

Example Output
```shell
> Enter the first name: J
> Enter the last name:
> Enter the ZIP code: ABCDE
> Enter an employee ID: A12-1234
> "J" is not a valid first name. It is too short.
> The last name must be filled in.
> The ZIP code must be numeric.
> A12-1234 is not a valid ID.

> Enter the first name: Jimmy
> Enter the last name: James
> Enter the ZIP code: 55555
> Enter an employee ID: TK-421
> There were no errors found.
```

* შექმენით ფუნქცია თითოეული ტიპის ვალიდაციისთვის. შემდეგ შექმენით validateInput ფუნქცია, რომელიც იღებს ყველა Input-ის მონაცემს და იძახებს კონკრეტული ვალიდაციის ფუნქციებს.

#### პროექტი 46 - Camel Case
თუ ცვლადი არაერთ სიტყვას შეიცავს, ზოგიერთ ენაში ხშირია ცვლადების სახელებისთვის camel case-ის გამოყენება, - პირველი სიტყვის პირველი ასო პატარაა, ყოველი მომდევნო სიტყვის პირველი ასო კი დიდი. მაგალითად, მომხმარებლის სახელის ცვლადს შეიძლება ეწოდოს firstName, მისთვის სასურველი მეტსახელისთვის კი - preferredFirstName.

ზოგიერთ ენაში ამის საპირისპიროდ ე.წ. snake case გამოიყენება, სადაც სიტყვები გამოყოფილია ქვედა ხაზებით (_) და ყველა ასო მცირე რეგისტრშია. მაგალითად, იმავე ცვლადებს დაერქმევა first_name და preferred_first_name.

შექმენით პროგრამა, რომელიც მომხმარებელს მოუწოდებს, input-ად შეიყვანოს ცვლადის სახელი camel case-ში, პროგრამამ კი უნდა დაბეჭდოს იგივე სახელი snake case-ში. დაუშვით, რომ მომხმარებლის ჩანაწერი აუცილებლად camel case სტილში იქნება. 

Example Output
```shell
> camelCase: name
> snake_case: name
> camelCase: firstMame
> snake_case: first_name
> camelCase: preferredFirstName
> snake_case: preferred_first_name

```

#### პროექტი 47 - Coke Machine - კოკა-კოლის მანქანა
დავუშვათ, რომ მანქანა ყიდის კოკა-კოლას ბოთლებს 50 ცენტად. მასში მხოლოდ შემდეგი მონეტების ჩაგდება შეგვიძლია: 25-ცენტიანი, 10-ცენტიანი და 5-ცენტიანი.

დაწერეთ პროგრამა, რომელიც Input-ად სთხოვს მომხმარებელს მონეტის "ჩაგდებას" მანამ, სანამ თანხა 50 ცენტს არ მიაღწევს. პროგრამამ ყოველი მონეტის "ჩაგდების" შემდეგ მომხმარებელს უნდა აცნობოს, რამდენი დარჩა გადასახდელი და კვლავ სთხოვოს input-ის შეყვანა. მას შემდეგ, რაც მომხმარებელი მინიმუმ 50 ცენტს შეიტანს, დაბეჭდეთ, რამდენი ცენტი ხურდა ეკუთვნის მას. დაუშვით, რომ მომხმარებელი მხოლოდ მთელ რიცხვებს შეიყვანს - ყველა ისეთი რიცხვის იგნორირება მოახდინეთ, რომელიც დაშვებული მონეტებიდან არც ერთს არ ემთხვევა.

Example Output
```shell
> Amount Due: 50
> Insert Coin: 25
> Amount Due: 25
> Insert Coin: 10
> Amount Due: 15
> Insert Coin: 5
> Amount Due: 10
> Insert Coin: 10
> Change Owed: 0
```

#### პროექტი 48 - Just setting up my twttr - ჩემი twttr-ის დაყენება
ტექსტური შეტყობინებების ან ე.წ. "ტვიტების" გაგზავნისას, არც ისე იშვიათია სიტყვების შემოკლება დროისა და შეტყობინების სიგრძის დაზოგვის მიზნით. ეს ხშირად ხმოვანთა გამოტოვების ხარჯზე ხდება, როგორც თავდაპირველად Twitter-ს ეძახდნენ twttr-ს. 

შექმენით პროგრამა, რომელიც მომხმარებელს სთხოვს ტექსტის შეყვანას და შემდეგ იმავე ტექსტს დაბეჭდავს, მაგრამ ყველა ხმოვანს (A, E, I, O და U) გამოტოვებს, მიუხედავად იმისა, დიდი ასოებით ეწერა ისინი თუ - პატარა ასოებით.

Example Output
```shell
> Input: Twitter
> Output: Twttr
> Input: What's your name?
> Output: Wht's yr nm?
```

### სავარჯიშოები

1. დაწერეთ ფუნქცია, რომელიც პარამეტრად მიიღებს ობიექტს და დააბრუნებს მის name ფროფერთის მნიშვნელობას. თუ name ფროფერთი არ გააჩნია, დაარეთარნეთ null.
2. გადააწყეთ პირველი დავალება try/catch-ის გამოყენებით. თუ name ფროფერთი არ გააჩნია, გაისროლეთ ერორი და შემდეგ გაუმკლავდით.
3. დაწერეთ ფუნქცია, რომელიც იღებს ორ რიცხვს პარამეტრებად და ცდილობს მათ გაყოფას. თუ რომელიმე რიცხვის ტიპის არაა, გაისროლეთ ერორი. ასევე გაუმკლავდით იმ შემთხვევასაც, როცა მეორე რიცხვი 0-ია (0-ზე გაყოფა არ შეიძლება).
4. დაწერეთ ფუნქცია სახელად promptAge, რომელიც შეეკითხება მომხმარებელს თავის ასაკს და თუ არასწორად იქნება ასაკი შემოყვანილი, გასივრის ერორს. ეს ფუნქცია გამოიძახეთ isAdult ფუნქციაში, რომელიც ადგენს არის თუ არა მომხმარებელი სრულწლოვანი. გამოიყენეთ try/catch ერორების გასამკლავებლად.
5. დაწერეთ ფუნქცია, რომელიც ცდილობს JSON სტრინგის პარსინგს (მაგალითად სტრინგად ჩაწერილ ობიექტს გადაიყვანს ობიექტში). გამოიყენეთ try/catch იმ ქეისებისთვის, როცა JSON სტრინგი არავალიდურია.
6. დაწერეთ ფუნქცია, რომელიც აგზავნის რექვესთს GitHub-ის API-ზე და მოაქვს გითჰაბის იუზერის დატა. (მაგალითად: https://api.github.com/users/temuritsutskiridze). თუ სასურველი პასუხი ვერ მიიღეთ (როცა response.ok არის false), გაისროლეთ ერორი და გამკლავდით მას. გამოიყენეთ async/await სინტაქსი.


#### Retry
Say you have a function primitiveMultiply that in 20 percent of cases multiplies two numbers and in the other 80 percent of cases raises an exception of type MultiplicatorUnitFailure. Write a function that wraps this clunky function and just keeps trying until a call succeeds, after which it returns the result.

Make sure you handle only the exceptions you are trying to handle.
```shell
class MultiplicatorUnitFailure extends Error {}

function primitiveMultiply(a, b) {
  if (Math.random() < 0.2) {
    return a * b;
  } else {
    throw new MultiplicatorUnitFailure("Klunk");
  }
}

function reliableMultiply(a, b) {
  // Your code here.
}

console.log(reliableMultiply(8, 8));
// → 64
```

#### The locked box
Consider the following (rather contrived) object:
```shell
const box = {
  locked: true,
  unlock() { this.locked = false; },
  lock() { this.locked = true;  },
  _content: [],
  get content() {
    if (this.locked) throw new Error("Locked!");
    return this._content;
  }
};
```
It is a box with a lock. There is an array in the box, but you can get at it only when the box is unlocked. Directly accessing the private _content property is forbidden.

Write a function called withBoxUnlocked that takes a function value as argument, unlocks the box, runs the function, and then ensures that the box is locked again before returning, regardless of whether the argument function returned normally or threw an exception.

```shell
const box = {
  locked: true,
  unlock() { this.locked = false; },
  lock() { this.locked = true;  },
  _content: [],
  get content() {
    if (this.locked) throw new Error("Locked!");
    return this._content;
  }
};

function withBoxUnlocked(body) {
  // Your code here.
}

withBoxUnlocked(function() {
  box.content.push("gold piece");
});

try {
  withBoxUnlocked(function() {
    throw new Error("Pirates on the horizon! Abort!");
  });
} catch (e) {
  console.log("Error raised: " + e);
}
console.log(box.locked);
// → true
```

For extra points, make sure that if you call withBoxUnlocked when the box is already unlocked, the box stays unlocked.
