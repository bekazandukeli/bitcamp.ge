---
title: თავი 12 - Algorithms - JavaScript 2024W
description: სასწავლო რესურსები
---

### ლექცია 12

<iframe
  width="560"
  height="315"
  src="https://www.youtube.com/embed/Qb1BBYKNHhY?si=W9_GfX3-rtgsMMnd"
  title="YouTube video player"
  frameborder="0"
  allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
  referrerpolicy="strict-origin-when-cross-origin"
  allowFullScreen
></iframe>

- Source code: [GitHub](https://github.com/TemuriTsutskiridze/JS-2024W-week12-theory)

### პრაქტიკული სემინარები

<Card>
  <PinCodeProtectedContent>
    <Locked>
      ეს კონტენტი განკუთვნილია აქტიური სტუდენტებისთვის. პინ კოდი მოითხოვეთ
      მენტორთან!
    </Locked>
    <Unlocked>
      - ოთხშაბათი: https://youtu.be/OzNAia2A0Ws
        - Source Code: [GitHub](https://github.com/TemuriTsutskiridze/JS-2024W-week12-seminar1)
      - პარასკევი: https://youtu.be/5QxL4F_o92U
        - Source Code: [GitHub](https://github.com/kachkacha2003/kadaneAlgo/blob/master/script.js)
    </Unlocked>
  </PinCodeProtectedContent>
</Card>

### რესურსები

- ედიტორი: [stackblitz.com](https://stackblitz.com)
- პრეზენტაცია: [Google Slide](https://docs.google.com/presentation/d/14APiKUPfyZBmYNfsZXmwHUgwgtSIwIQSZCV8it2E05M/edit?usp=sharing)
- [Bubble Sort Vizualization](https://www.hackerearth.com/practice/algorithms/sorting/bubble-sort/visualize/)


### წასაკითხი

- [Binary Search](https://www.techiedelight.com/binary-search/)


### დავალებები

#### პროექტი 64 - Filtering Records - ჩანაწერების გაფილტვრა
ჩანაწერების დახარისხება სასარგებლოა, მაგრამ ზოგჯერ საჭიროა შედეგების გაფილტვრა, რათა იპოვოთ ან აჩვენოთ მხოლოდ ის, რასაც ეძებთ.

მოცემული მონაცემებთა ნაკრების გათვალისწინებით:

| **First Name** | **Last Name**  | **Position** | **Separation date**  |
| --------- | --------- | ------------------- | ----------------- |
| John  | Johnson |  Manager |  2016-12-31 |
| Tou | Xiong | Software Engineer | 2016-10-05 |
| Michaela | Michaelson | District Manager | 2015-12-19 |
| Jake | Jacobson | Programmer |  |
| Jacquelyn | Jackson | DBA |  |
| Sally    | Weber| Web Developer | 2015-12-18 |

შექმენით პროგრამა, რომელიც საშუალებას აძლევს მომხმარებელს, აღმოაჩინოს ის ჩანაწერები, რომელიც ემთხვევა მის საძიებო სტრიქონს. უნდა მოხდეს საძიებო სტრიქონის შედარება სახელის ან გვარის ველთან.

მაგალითად:
```shell
> Enter a search string: Jac
> Results:

| **Name** | **Position** | **Separation date**  |
| --------- | ------------ | -------------- |
| Jacquelyn Jackson | DBA |  |
| Jake Jacobson | Programmer |  |

```

* მონაცემები იქონიეთ ობიექტების მასივში.

დამატებითი გამოწვევა:
* ჰკითხეთ მომხმარებელს, როგორ დალაგდეს ჩანაწერები. დაუშვით დახარისხება თარიღის, პოზიციის ან გვარის მიხედვით.

#### პროექტი 65 - Who’s in Space? - ვინ არის კოსმოსში?

იცოდით, რომ ზუსტად შეგიძლიათ გაიგოთ, ვინ არის ახლა კოსმოსში? ამის შესახებ ინფორმაციას Open Notify API გვაწვდის. ეწვიეთ ბმულს: http://api.open-notify.org/astros.json, რომ ნახოთ არა მხოლოდ რამდენი ადამიანი იმყოფება ამჟამად კოსმოსში, არამედ - მათი სახელები და ის, თუ რომელ კოსმოსურ ხომალდზე იმყოფებიან.

შექმენით პროგრამა, რომელიც ამოიღებს ამ მონაცემებს და აჩვენებს ინფორმაციას ამ API-დან ცხრილის ფორმატში.

მაგალითად:
```shell
| **Name** | **Craft** | 
| --------- | ------------ | 
| Gennady Padalka | ISS |
| Mikhail Kornienko | ISS |
| Scott Kelly |  ISS |  

```

#### პროექტი 66 - Grabbing the Weather - ამინდის გაგება

დღეს კარგი ამინდი იქნება? თუ ქურთუკი უნდა ვიქონიი? OpenWeatherMap API-ის გამოყენებით, ბმულით: http://openweathermap.org/ , შექმენით პროგრამა, რომელიც მოგთხოვთ ქალაქის სახელს და დააბრუნებს ქალაქის მიმდინარე ტემპერატურას.

მაგალითად:
```shell
> Where are you? Chicago IL
> Chicago weather:
> 65 degrees Fahrenheit
```

#### პროექტი 67 - Grabbing the Weather - ამინდის გაგება

ნეტავ, დღეს კარგი ამინდი იქნება? თუ ქურთუკი უნდა ვიქონიი? OpenWeatherMap API-ის გამოყენებით, ბმულით: http://openweathermap.org/ , შექმენით პროგრამა, რომელიც მოგთხოვთ ქალაქის სახელს და დააბრუნებს ქალაქის მიმდინარე ტემპერატურას.

მაგალითად:
```shell
> Where are you? Chicago IL
> Chicago weather:
> 65 degrees Fahrenheit
```

#### პროექტი 68 - Flickr Photo Search - ფოტოს ძებნა Flickr-ზე

ზოგიერთი სერვისი ძიების ფუნქციებს უზრუნველჰყოფს და გაძლევთ კონტროლი საშუალებას თქვენ მიერ მიღებულ შედეგებზე. თქვენ მხოლოდ სწორი მოთხოვნის (request) ჩამოყალიბება გჭირდებათ. შექმენით პროგრამა გრაფიკული ინტერფეისით, რომელიც იღებს საძიებო სტრიქონს (string) და აჩვენებს ფოტოებს, რომლებიც შეესაბამება ამ ძიებას. სერვისად გამოიყენეთ Flickr-ის საჯარო ფოტოების ბმული: https://www.flickr.com/services/feeds/docs/photos_public/ 

#### პროექტი 69 - Movie Recommendations - ფილმის რეკომენდაციები

დაწერეთ პროგრამა, რომელიც აჩვენებს ინფორმაციას მოცემული ფილმის შესახებ. გამოიყენეთ Rotten Tomatoes-ს API მისამართზე: http://developer.rottentomatoes.com/ და მიიღეთ API key. მოითხოვეთ საძიებო input და აჩვენეთ შემდეგი მონაცემები: სათაური, წელი, რეიტინგი, გამოშვების დრო და მოკლე შინაარსი, თუ ასეთი არსებობს. მაშინ, თუ ფილმისთვის აუდიტორიის მიერ მიცემული შეფასება 80%-ს აღემატება, პროგრამა რეკომენდაციას უწევს მომხმარებელს, რომ ეს ფილმი ახლავე ნახოს. თუ ქულა 50%-ზე დაბალია, რეკომენდაციაა, რომ მომხმარებელმა ფილმის ყურებას თავი აარიდოს. 

მაგალითად:
```shell
> Enter the name of a movie: Guardians of the Galaxy
> Title: Guardians of the Galaxy
> Year: 2014
> Rating: PG-13
> Running Time: 121 minutes
> Description: From Marvel...
> You should watch this movie right now!
```

### დამატებითი შემაჯამებელი პროექტები

#### პროექტი 70 - Frank, Ian and Glen’s Letters - ფრენკის, იანის და გლენის წერილები

FIGlet, სახელწოდებით ფრენკის, იანის და გლენის წერილების მიხედვით, არის პროგრამა 1990-იანი წლების დასაწყისიდან, რომელიც განკუთვნილია ჩვეულებრივი ტექსტისგან დიდი ასოების შესაქმნელად, ესაა ე.წ. ASCII ხელოვნების ერთგვარი ფორმა:

_ _ _          _   _     _
| (_) | _____  | |_| |__ (_)___
| | | |/ / _ \ | __| '_ \| / __|
| | |   <  __/ | |_| | | | \__ \
|_|_|_|\_\___|  \__|_| |_|_|___/

FIGlet-ის მიერ მხარდაჭერილ შრიფტებს შორის არის figlet.org/examples.html.

განახორციელეთ პროგრამა, რომელიც:

ელოდება ორ არგუმენტს მომხმარებლის input-ის სახით:
- ტექსტის str-ს (სტრიქონს).
- სასურველი შრიფტის სახელწოდებას.

შემდეგ კი პროგრამამ უნდა გამოიტანოს ჩაწერილი ტექსტი სასურველი შრიფტით.

მაგალითად:
```shell                                                            
> Text: hello, world   
> Font: Standard                                                          
> Output:
_          _ _                             _     _                            
| |__   ___| | | ___    __      _____  _ __| | __| |                           
| '_ \ / _ \ | |/ _ \   \ \ /\ / / _ \| '__| |/ _` |                           
| | | |  __/ | | (_) |   \ V  V / (_) | |  | | (_| |                           
|_| |_|\___|_|_|\___( )   \_/\_/ \___/|_|  |_|\__,_|                           
                   |/                                                         
                                                                              
```

```shell                                                            
> Text: hello, world   
> Font: slant                                                           
> Output:
   __         ____                               __    __                     
  / /_  ___  / / /___       _      ______  _____/ /___/ /                     
 / __ \/ _ \/ / / __ \     | | /| / / __ \/ ___/ / __  /                      
/ / / /  __/ / / /_/ /     | |/ |/ / /_/ / /  / / /_/ /                       
/_/ /_/\___/_/_/\____( )    |__/|__/\____/_/  /_/\__,_/                        
                    |/                                                        
                                                                              
                                                                              
```                                                                      

P.S. პროგრამის შესასრულებლად თქვენს ტერმინალში გაუშვით შემდეგი ბრძანება: npm install figlet, რათა მოდულზე წვდომა გქონდეთ, ასევე, კოდის თავში დაწერეთ შემდეგი კოდი: const figlet = require("figlet");


#### პროექტი 71 - Testing my twttr - ჩემი twttr-ის ტესტირება

ხელახლა დაწერეთ Setting up my twttr-ის კოდი ქვემოთ მოცემული სტრუქტურით, სადაც shorten ელოდება str-ს input-ად და აბრუნებს იმავე str-ს, მაგრამ ყველა ხმოვანის (A, E, I, O, და U) გამოტოვებით, მიუხედავად იმისა, ისინი პატარა რეგისტრშია თუ - დიდში. 
```shell  
function main() {
    
}

function shorten(word) {
    
}
```

შემდეგ, სხვა ფაილში, შექმენით ერთი ან მეტი ფუნქცია, რომელიც ერთობლივად ამოწმებს თქვენი კოდის მუშაობას.

#### პროექტი 72 - Back to Bank - ბანკის პროგრამის ტესტირება

ხელახლა დაწერეთ პროგრამა Home Federal Savings Bank, მოახდინეთ თქვენი კოდის რესტრუქტურიზაცია ქვემოთ მოცემულის მიხედვით, სადაც value ელოდება str-ს (სტრიქონს) input-ად, შემდეგ აბრუნებს მთელ რიცხვს (int), კერძოდ 0-ს, იმ შემთხვევაში, თუ ეს str იწყება "hello"-თი; 20-ს, თუ str იწყება "h"-თი (მაგრამ არ არის "hello") და 100-ს ყველა სხვა შემთხვევაში. str-ში ჩაწერილ დაბალი ან მაღალი რეგისტრის სიმბოლოებს მნიშვნელობა არ მიანიჭოთ. შეგიძლიათ, ივარაუდოთ, რომ სტრიქონი, რომელიც value ფუნქციას გადაეცემა, ასოებამდე, წინ სივრცეს (space) არ შეიცავს. მხოლოდ main ფუნქციამ უნდა დაბეჭდოს შედეგი.
```shell  
function main() {
...
}
    

function value(greeting) {
 ...
}
``` 
სხვა ფაილში შექმენით სამი ან მეტი ფუნქცია, რომლებიც ერთობლივად შეამოწმებენ თქვენი კოდის მუშაობას.

#### პროექტი 73 - Re-requesting a Vanity Plate - "სანომრე ნიშნების" ხელახლა აღება

<iframe width="560" height="315" src="https://www.youtube.com/embed/mQZmCJUSC6g?si=cgVAythYMFfl7JHv" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>

ახლიდან დაწერეთ პროგრამა Vanity Plates, თქვენი კოდის რესტრუქტურიზაცია კი მოახდინეთ ქვემოთ მოცემულის მიხედვით, სადაც isValid ელოდება str-ს input-ის სახით და აბრუნებს true-ს, თუ ეს str აკმაყოფილებს ყველა მოთხოვნას, ხოლო თუ ვერ აკმაყოფილებს, მაშინ - false-ს.
```shell  
function main() {
    ...
}

function isValid(s) {
    ...
}
``` 
სხვა ფაილში დაწერეთ ოთხი ან მეტი ფუნქცია, რომლებიც ერთობლივად და საფუძვლიანად შეამოწმებენ თქვენს isValid ფუნქციაში დაწერილ კოდს.

#### პროექტეი 74 - Refueling - საწვავის ხელახლა შევსება

ხელახლა შექმენით Fuel Gauge პროგრამა, თქვენი კოდის რესტრუქტურიზაცია კი ქვემოთ მოცემულის მიხედვით მოახდინეთ.

convert ფუნქცია input-ად ელის str-ს - X/Y ფორმატში (სადაც X-იც და Y-იც მთელი რიცხვებია) და აბრუნებს ამ წილადს პროცენტის სახით, რომელიც დამრგვალებულია უახლოეს მთელ რიცხვამდე (int) 0-დან 100-ის ჩათვლით. თუ X და/ან Y არ არის მთელი რიცხვი, ან თუ X მეტია Y-ზე, მაშინ კონვერტაციამ უნდა გამოიწვიოს შეცდომა (Error - გამოიყენეთ throw statement). თუ Y არის 0, მაშინ კონვერტაციამ უნდა გამოიწვიოს სხვა შეცდომა, რომელიც მიუთითებს, რომ 0-ზე გაყოფა არ შეიძლება.

gauge ფუნქცია ელის int-ს და აბრუნებს str-ს, რომელიც არის:
- "E", თუ ეს int არის 1-ზე ნაკლები ან მისი ტოლი;
- "F", თუ ეს int არის 99-ზე მეტი ან მისი ტოლი;
- და "Z%" ნებისმიერ სხვა შემთხვევაში, სადაც Z წარმოადგენს აღნიშნულ მთელ რიცხვს (int-ს).
```shell  
function main() {
    ...
}

function convert(fraction) {
    ...
}

function gauge(percentage) {
    ...
}
``` 
შექმენით ორი ან მეტი ფუნქცია, რომლებიც ერთობლივად შეამოწმებენ convert-ისა და gauge-ს კოდის ფუნქციონირებას.

#### პროექტი 75 - Pizza Py - პინოქიოს პიცა

<iframe width="560" height="315" src="https://www.youtube.com/embed/TkABR72j7jU?si=eppYeKTFG7wqGkhm" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>

ჰარვარდის მოედანზე ყველაზე პოპულარული პიცერია არის Pinocchio's Pizza & Subs, aka Noch's, რომელიც ცნობილია თავისი სიცილიური პიცით.

ჩვეულებრივ, სტუდენტები პიცას ნაჭრებად ყიდულობენ, მაგრამ Pinocchio's-ს ასევე მენიუში აქვს მთელი პიცაც, სიცილიური პიცების ამ CSV ფაილის, sicilian.csv-ის თანახმად, იხილეთ:

Sicilian Pizza,Small,Large

Cheese,$25.50,$39.95
1 item,$27.50,$41.95
2 items,$29.50,$43.95
3 items,$31.50,$45.95
Special,$33.50,$47.95

ასევე, ჩვეულებრივი პიცების CSV ფაილი იხილეთ: https://cs50.harvard.edu/python/2022/psets/6/pizza/regular.csv

რა თქმა უნდა, CSV ფაილი არ არის მომხმარებლისთვის ყველაზე მოსახერხებელი ფორმატი. უფრო ლამაზი შეიძლება იყოს ცხრილი, ფორმატირებული, როგორც ASCII, შემდეგნაირად:

+------------------+---------+---------+
| Sicilian Pizza   | Small   | Large   |
+==================+=========+=========+
| Cheese           | $25.50  | $39.95  |
+------------------+---------+---------+
| 1 item           | $27.50  | $41.95  |
+------------------+---------+---------+
| 2 items          | $29.50  | $43.95  |
+------------------+---------+---------+
| 3 items          | $31.50  | $45.95  |
+------------------+---------+---------+
| Special          | $33.50  | $47.95  |
+------------------+---------+---------+


შექმენით პროგრამა, რომელიც გამოსცემს ცხრილს, რომელიც ფორმატირებულია ASCII art-ის tabulate-ს სახით. შეგიძლიათ ამგვარი დაფორმატებისთვის საჭირო კოდი თავად დაწეროთ, ან, ალტერნატიულად, გამოიყენოთ რომელიმე package.

#### პროექტი 76 - Scourgify

- აჰ, კარგი, - თქვა ტონკსმა და საბარგული დახურა, - ცოტა გაწმენდა არ აწყენდა, - მან ჯოხი ჰედვიგის გალიას მიუშვირა, - Scourgify! -  დარჩენილი რამდენიმე ბუმბული გაქრა.
- “ჰარი პოტერი და ფენიქსის ორდენი”

მონაცემებსაც ხშირად სჭირდება „გაწმენდა“, როგორც მისი ფორმატის ცვლილება, რათა მნიშვნელობები უფრო ორგანიზებულ ფორმატში იყოს. განვიხილოთ, მაგალითად, სტუდენტების ეს CSV ფაილი, before.csv : https://cs50.harvard.edu/python/2022/psets/6/scourgify/before.csv:

name,house
"Abbott, Hannah",Hufflepuff
"Bell, Katie",Gryffindor
"Bones, Susan",Hufflepuff
...

მიუხედავად იმისა, რომ ფაილში თითოეულ "ხაზში" (row) გვხვდება სამი მნიშვნელობა (გვარი, სახელი და ჰოგვორტსის სახლი), პირველი ორი გაერთიანებულია ერთ „სვეტში“ (column) - name, რომელიც გამოყოფილია ორმაგი ბრჭყალებით, გვარსა და სახელს კი მძიმე და ერთი ინტერვალი (space) ჰყოფთ. თუ ჰოგვარტსს სურს, თითოეულ სტუდენტს წერილი გაუგზავნოს, მაგალითად, ერთობლივად - მეილის საშუალებით, ეს იდეალური მოცემულობა არ არის. უცნაური იქნებოდა წერილის დაწყება შემდეგი სიტყვებით:

Dear Potter, Harry,

ამის ნაცვლად, უნდა იყოს, მაგალითად:

Dear Harry,

შექმენით პროგრამა, რომელიც ამ მონაცემებს გარდაქმნის აღნიშნული სახის output-ად, ყოფს თითოეულ გაერთიანებულ სახელსა და გვარს ცალ-ცალკე: სახელად და გვარად. ეს ნიშნავს, რომ "Potter, Harry",Gryffindor - ის მაგივრად, გვექნება: Harry,Potter,Gryffindor


### სავარჯიშოები

1. Anagram Checker
დაწერეთ ფუნქცია, რომელიც მიიღებს ორ სტრინგს პარამეტრად და დაადგენს, არიან თუ არა ერთმანეთის ანაგრამები. ანაგრამებია სიტყვები, თუ ისინი შეიცავენ ერთი და იმავე სიმბოლოებს.

2. Prime Number Generator
დაწერეთ ფუნქცია, რომელიც მიიღებს შუალედს პარამეტრებად და დააბრუნებს მასივს, რომელშიც იქნება ამ შუალედღი მყოფი მარტვი რიცხვები.

3. Unique Elements
დაწერეთ ფუნქცია, რომელიც მიიღწებს ელემენტების მასივს პარამეტრად და დააბრუნებს უნიკალური ელემენტების მასივს (მასივიდან ამოყრილ დუპლიკატებს)

4. Palindrome Checker
დაწერეთ ფუნქცია, რომელიც მიიღებს სტრინგს პარამეტრად და დაადგენს, არის თუ არა პალინდრომი.

5. Largest Sum Subarray
დაწერეთ ფუნქცია, რომელიც მიიღებს რიცხვების მასივს პარამეტრად და იპოვის ისეთ მიმდევრობას, რომლის ჯამი არის უდიდესი. დააბრუნეთ ნაპოვნი ქვემასივის ჯამი. 

6. Missing Number
დაწერეთ ფუქნცია, რომელიც პარამეტრად იღებს რიცხვების მასივს. რიცხვები იქნება 1-დან n-მდე, ოღონდ გამოტოვებული იქნება ერთი რიცხვი. ფუნქცია უნდა აბრუნებდეს გამოტოვებულ რიცხვს. bonus: მასივში რომ იყოს რამდენიმე გამოტოვებული რიცხვი, ფუნქციამ ყველა გამოტოვებული რიცხვი დააბრუნოს.

7. Deep Clone
დაწერეთ ფუნქცია, რომელიც ობიექტზე ჩაატარებს deep clone-ს, ანუ შექმნის ახალ ობიექტს იმავე სტრუქტურით ისე, რომ წინასთან reference დაკარგული ექნება.

8. Longest Common Prefix
დაწერეთ ფუნქცია, რომელიც მიიღებს სტრინგების მასივს პარამეტრად და იყოვის ყველაზე გრელ საერთო პრეფიქსს, რომლითაც ყველა სტრინგი იწყება. დააბრუნეთ ცარიელი სტრინგი, თუ საერთო პრეფიქსი არ არსებობს.

9. დაწერეთ ფუნქცია, რომელიც პარამეტრად იღებს გარკვეული რაოდენობის მასივს(გამოიყენეთ rest parameter) და დაბრუნეთ საერთო ელემენტების მასივი (საერთო ელემენტია ის ელემენტი, რომელიც პარამეტრად შემოსულ ყველა მასივში მდებარეობს)


შეგიძლია ივარჯიშო ამ საიტებზეც: 
[CodeWars](https://www.codewars.com/dashboard)
[LeetCode](https://leetcode.com)